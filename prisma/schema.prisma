
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Enquiry {
  id              String        @id @default(cuid()) // Unique identifier for each enquiry
  name            String // User's name
  whatsappNumber  String // User's WhatsApp number
  email           String // User's email, must be unique
  courseId        Int // Preferred course (foreign key)
  slotId          Int // Preferred slot (foreign key)
  createdAt       DateTime      @default(now()) // Timestamp for when the enquiry was submitted
  paymentVerified Boolean       @default(false) // Track if payment is verified
  transaction     Transaction[] @relation // Relation to Transaction, one-to-many

  course Course @relation(fields: [courseId], references: [id])
  slot   Slot   @relation(fields: [slotId], references: [id])

  // Index on email for faster queries
  // Index on courseId and slotId for faster queries
  @@index([email])
  @@index([courseId, slotId])
}

model Course {
  id        Int       @id @default(autoincrement()) // Unique identifier for courses
  name      String // Course name  
  slots     Slot[] // One-to-many relationship with Slot
  enquiries Enquiry[] // One-to-many relationship with Enquiry
}

model Slot {
  id        Int       @id @default(autoincrement()) // Unique identifier for slots
  slotName  String // Slot name
  courseId  Int // Foreign key to the Course model
  course    Course    @relation(fields: [courseId], references: [id])
  enquiries Enquiry[] // One-to-many relationship with Enquiry
}

model Transaction {
  id            String   @id @default(cuid()) // Unique identifier for the transaction
  enquiryId     String?  // Foreign key to the Enquiry model (nullable to allow SetNull behavior)
  amount        Float    // Payment amount
  status        String   // Payment status (e.g., 'completed', 'failed', 'pending')
  transactionId String   // Unique transaction ID from the payment gateway
  createdAt     DateTime @default(now()) // Timestamp for when the transaction was created
  updatedAt     DateTime @updatedAt  // Timestamp for when the transaction was last updated   
  userMail      String   // User's email

  enquiry Enquiry? @relation(fields: [enquiryId], references: [id], onDelete: SetNull)
}

model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}
